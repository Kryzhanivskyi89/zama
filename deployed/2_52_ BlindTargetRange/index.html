<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Blind Target Range ‚Äî Zama FHEVM</title>
  <style>
  :root {
  --bg: radial-gradient(circle at 50% 50%, #0c1a0c 0%, #050805 100%);
  --card-bg: rgba(0, 60, 0, 0.15);
  --border: rgba(0, 255, 60, 0.2);
  --text: #c8ffda;
  --accent: #38ff76;
  --accent2: #8cffc7;
  --success: #42ff9e;
  --warning: #ffe866;
  --error: #ff6464;
  --radius: 14px;
  --grid-line: rgba(0, 255, 85, 0.06);
  --glow: 0 0 6px rgba(0,255,120,0.8);
}

* { 
  box-sizing: border-box;
  font-family: 'JetBrains Mono', 'Consolas', monospace;
}

body {
  margin: 0;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  padding: 40px;
  position: relative;
}

/* Radar grid overlay */
body::before {
  content: "";
  pointer-events: none;
  position: fixed;
  inset: 0;
  background-image:
    linear-gradient(var(--grid-line) 1px, transparent 1px),
    linear-gradient(90deg, var(--grid-line) 1px, transparent 1px);
  background-size: 45px 45px;
  opacity: 0.28;
  z-index: 0;
}

/* Subtle CRT scanline */
body::after {
  content: "";
  pointer-events: none;
  position: fixed;
  inset: 0;
  background: repeating-linear-gradient(
    to bottom,
    rgba(0, 255, 70, 0.03),
    rgba(0, 255, 70, 0.03) 2px,
    transparent 2px,
    transparent 4px
  );
  mix-blend-mode: overlay;
  opacity: 0.4;
  z-index: 0;
}

.container {
  position: relative;
  z-index: 5;
  max-width: 1200px;
  margin: auto;
  display: flex;
  flex-direction: column;
  gap: 30px;
}

header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 20px;
}

h1 {
  font-size: 2rem;
  letter-spacing: 1px;
  color: var(--accent);
  text-shadow: var(--glow);
  margin: 0;
}

h2 {
  font-size: 1.2rem;
  margin: 0 0 16px 0;
  color: var(--accent2);
  text-shadow: 0 0 4px rgba(0,255,120,0.5);
}

.btn {
  border: 1px solid var(--accent);
  border-radius: var(--radius);
  padding: 12px 20px;
  font-weight: 600;
  cursor: pointer;
  background: rgba(0, 40, 0, 0.5);
  color: var(--accent);
  transition: all 0.25s;
  text-shadow: 0 0 6px var(--accent);
}

.btn:hover {
  background: rgba(0, 120, 0, 0.25);
  box-shadow: var(--glow);
  transform: translateY(-2px);
}

.btn-secondary { border-color: #88ffae; color: #88ffae; }
.btn-success { border-color: var(--success); color: var(--success); }

.btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
  filter: grayscale(100%);
}

.card {
  backdrop-filter: blur(6px);
  background: var(--card-bg);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 24px 28px;
  box-shadow: 0 0 15px rgba(0,255,80,0.05);
  position: relative;
}

/* corner brackets */
.card::before,
.card::after {
  content: "";
  position: absolute;
  width: 22px;
  height: 22px;
  border: 2px solid var(--accent);
  opacity: 0.25;
}

.card::before {
  top: 6px;
  left: 6px;
  border-right: none;
  border-bottom: none;
}

.card::after {
  bottom: 6px;
  right: 6px;
  border-left: none;
  border-top: none;
}

label {
  display: block;
  margin-top: 12px;
  font-weight: 600;
  font-size: 13px;
  color: #9cffc6;
}

input {
  width: 100%;
  margin-top: 6px;
  padding: 12px;
  border-radius: 8px;
  border: 1px solid rgba(0,255,120,0.2);
  background: rgba(0, 50, 0, 0.35);
  color: var(--text);
  font-size: 15px;
  transition: all 0.25s;
}

input:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: var(--glow);
}

.row {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  margin-top: 16px;
}

.col { flex: 1; min-width: 200px; }

pre {
  background: rgba(0, 60, 0, 0.25);
  border: 1px dashed var(--border);
  border-radius: 12px;
  padding: 16px;
  overflow: auto;
  font-size: 12px;
  max-height: 300px;
  color: var(--accent);
  box-shadow: inset 0 0 10px rgba(0,255,80,0.05);
}

.status {
  font-size: 14px;
  padding: 8px 12px;
  border-radius: 8px;
  margin-top: 8px;
  background: rgba(0,255,60,0.05);
  border-left: 3px solid var(--accent);
  text-shadow: 0 0 6px rgba(0,255,120,0.4);
}

.status.pending { color: var(--warning); border-color: var(--warning); }
.status.success { color: var(--success); border-color: var(--success); }
.status.error { color: var(--error); border-color: var(--error); }

.info-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-top: 12px;
}

.info-item {
  padding: 12px;
  background: rgba(0, 50, 0, 0.35);
  border-radius: 8px;
  border: 1px solid rgba(0,255,120,0.12);
}

.info-label { font-size: 11px; color: #8affb8; }
.info-value { font-weight: 700; margin-top: 4px; color: #d4ffe6; }

.match-result {
  padding: 18px;
  background: rgba(0, 255, 100, 0.12);
  border-left: 4px solid var(--success);
  border-radius: 8px;
  margin-top: 16px;
  text-shadow: 0 0 6px rgba(0,255,120,0.5);
}

.match-result.no-match {
  background: rgba(255, 80, 80, 0.1);
  border-left-color: var(--error);
}

footer {
  text-align: center;
  color: #5aff9f;
  font-size: 13px;
  margin-top: 40px;
  opacity: 0.6;
}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üéØ Blind Target Range</h1>
      <button id="btnConnect" class="btn">Connect Wallet</button>
    </header>

    <!-- SUBMIT INTERVAL -->
    <section class="card">
      <h2>1Ô∏è‚É£ Submit Secret Interval</h2>
      <p style="color:#9ca3af;font-size:14px;">
        Register a hidden X-range [L, R] (encrypted on-chain).
      </p>

      <label>Left bound L (uint16)</label>
      <input id="leftBound" type="number" min="0" max="65535" value="40"/>

      <label>Right bound R (uint16)</label>
      <input id="rightBound" type="number" min="0" max="65535" value="60"/>

      <div class="row">
        <button id="btnSubmitInterval" class="btn">Register Interval</button>
        <div id="intervalStatus" class="status" style="display:none;"></div>
      </div>
      <div id="intervalInfo" class="info-grid" style="display:none;">
        <div class="info-item">
          <div class="info-label">Interval ID</div>
          <div class="info-value" id="intervalIdDisplay">‚Äî</div>
        </div>
        <div class="info-item">
          <div class="info-label">Your Address</div>
          <div class="info-value" id="intervalAddressDisplay" style="font-size:12px;">‚Äî</div>
        </div>
      </div>
    </section>

    <!-- SUBMIT SHOT -->
    <section class="card">
      <h2>2Ô∏è‚É£ Submit Encrypted Shot</h2>
      <p style="color:#9ca3af;font-size:14px;">
        Register a hidden shot coordinate X.
      </p>

      <label>Shot X (uint16)</label>
      <input id="shotX" type="number" min="0" max="65535" value="50"/>

      <div class="row">
        <button id="btnSubmitShot" class="btn btn-secondary">Register Shot</button>
        <div id="shotStatus" class="status" style="display:none;"></div>
      </div>
      <div id="shotInfo" class="info-grid" style="display:none;">
        <div class="info-item">
          <div class="info-label">Shot ID</div>
          <div class="info-value" id="shotIdDisplay">‚Äî</div>
        </div>
        <div class="info-item">
          <div class="info-label">Shooter Address</div>
          <div class="info-value" id="shotAddressDisplay" style="font-size:12px;">‚Äî</div>
        </div>
      </div>
    </section>

    <!-- COMPUTE HIT -->
    <section class="card">
      <h2>üîç 3Ô∏è‚É£ Compute Hit Zone</h2>
      <p style="color:#9ca3af;font-size:14px;">
        Compute homomorphic hit level (0=far, 1=near, 2=center) using encrypted thresholds.
      </p>

      <div class="row">
        <div class="col">
          <label>Interval ID</label>
          <input id="hitIntervalId" type="number" min="1" value="1"/>
        </div>
        <div class="col">
          <label>Shot ID</label>
          <input id="hitShotId" type="number" min="1" value="1"/>
        </div>
        <div class="col">
          <label>Near radius (uint16)</label>
          <input id="nearRadius" type="number" min="0" max="65535" value="20"/>
        </div>
        <div class="col">
          <label>Center radius (uint16)</label>
          <input id="centerRadius" type="number" min="0" max="65535" value="5"/>
        </div>
      </div>

      <div class="row">
        <button id="btnComputeHit" class="btn btn-success">Compute Hit (Homomorphic)</button>
        <div id="hitStatus" class="status" style="display:none;"></div>
      </div>
      <pre id="hitHandleOutput" style="display:none;">‚Äî</pre>
    </section>

    <!-- DECRYPT -->
    <section class="card">
      <h2>üîì 4Ô∏è‚É£ Retrieve & Decrypt Hit</h2>
      <p style="color:#9ca3af;font-size:14px;">
        Make hit result public and decrypt it via Relayer.
      </p>

      <div class="row">
        <div class="col">
          <label>Interval ID</label>
          <input id="decryptIntervalId" type="number" min="1" value="1"/>
        </div>
        <div class="col">
          <label>Shot ID</label>
          <input id="decryptShotId" type="number" min="1" value="1"/>
        </div>
      </div>

      <div class="row">
        <button id="btnGetHandle" class="btn btn-secondary">Get Hit Handle</button>
        <button id="btnMakePublic" class="btn">Make Public</button>
        <button id="btnDecrypt" class="btn btn-success">Decrypt Result</button>
      </div>

      <div id="decryptStatus" class="status" style="display:none;"></div>
      <div id="hitResult" class="match-result" style="display:none;"></div>
    </section>

    <footer>Built with ‚ù§Ô∏è & Zama FHEVM ¬∑ Relayer SDK 0.3.0-5 ¬∑ Ethers v6</footer>
  </div>

  <script type="module">
    import { initSDK, createInstance, SepoliaConfig } from "https://cdn.zama.org/relayer-sdk-js/0.3.0-5/relayer-sdk-js.js";
    import { BrowserProvider, Contract, getAddress } from "https://cdn.jsdelivr.net/npm/ethers@6.15.0/+esm";

    const CONFIG = {
      RELAYER_URL: "https://relayer.testnet.zama.org",
      GATEWAY_URL: "https://gateway.testnet.zama.org",
      CONTRACT_ADDRESS: "0xD3a7ba4dcA19a5D5324f8Bbab7AAa86e984e1D61"
    };

    const ABI = [
      "function submitInterval(bytes32,bytes32,bytes) external returns (uint256)",
      "function submitShot(bytes32,bytes) external returns (uint256)",
      "function computeHit(uint256,uint256,bytes32,bytes32,bytes) external returns (bytes32)",
      "function makeHitPublic(uint256,uint256) external",
      "function hitHandle(uint256,uint256) external view returns (bytes32)",
      "function intervalExists(uint256) external view returns (bool)",
      "function shotExists(uint256) external view returns (bool)",
      "function intervalOwner(uint256) external view returns (address)",
      "function shotOwner(uint256) external view returns (address)"
    ];

    let provider, signer, address, contract, relayer;
    const $ = s => document.querySelector(s);

    const log = (t, d) => console.log(`%c[${t}]`, "color:#38bdf8;font-weight:bold;", d);
    const logError = (t, e) => console.error(`%c[ERROR: ${t}]`, "color:#ef4444;font-weight:bold;", e);
    const logSuccess = (t, d) => console.log(`%c[SUCCESS: ${t}]`, "color:#10b981;font-weight:bold;", d);

    const toHex = u8 => "0x" + Array.from(u8, b => b.toString(16).padStart(2,"0")).join("");

    const setStatus = (id, msg, type="pending") => {
      const el = $(id);
      if (!el) return;
      el.textContent = msg;
      el.className = `status ${type}`;
      el.style.display = "block";
      log(`Status ${id}`, msg);
    };

    const clearStatus = id => {
      const el = $(id);
      if (el) el.style.display = "none";
    };

    function cleanHandle(raw) {
      return String(raw).trim().split("\n").pop().trim();
    }

    async function connect() {
      try {
        log("Connect", "Starting...");
        if (!window.ethereum) throw new Error("MetaMask not installed");

        provider = new BrowserProvider(window.ethereum);
        log("Provider", "Created");

        await provider.send("eth_requestAccounts", []);
        signer = await provider.getSigner();
        address = await signer.getAddress();
        log("Address", address);

        contract = new Contract(getAddress(CONFIG.CONTRACT_ADDRESS), ABI, signer);
        log("Contract", CONFIG.CONTRACT_ADDRESS);

        $("#btnConnect").textContent = address.slice(0,6) + "‚Ä¶" + address.slice(-4);

        if (!relayer) {
          log("Relayer", "initSDK...");
          await initSDK();
          relayer = await createInstance({
            ...SepoliaConfig,
            relayerUrl: CONFIG.RELAYER_URL,
            gatewayUrl: CONFIG.GATEWAY_URL,
            network: window.ethereum,
            debug: true
          });
          logSuccess("Relayer", "Instance created");
        }

        logSuccess("Connect", "Ready");
        return true;
      } catch (e) {
        logError("Connect", e);
        setStatus("#intervalStatus", "‚ùå Wallet connection failed", "error");
        return false;
      }
    }

    $("#btnConnect").onclick = connect;

    // ===== encrypt16 helper =====
    async function encrypt16(value) {
      if (!relayer) throw new Error("Relayer not initialized");

      const enc = relayer.createEncryptedInput(
        getAddress(CONFIG.CONTRACT_ADDRESS),
        getAddress(address)
      );
      log("Encrypt16", `add16=${value}`);
      enc.add16(BigInt(value));

      const { handles, inputProof } = await enc.encrypt();
      log("Encrypt16 Result", {
        handleCount: handles.length,
        proofLength: typeof inputProof === "string" ? inputProof.length : inputProof.length
      });

      const raw = handles[0]?.handle || handles[0]?.ciphertext || handles[0];
      const handle = typeof raw === "string" ? raw : toHex(raw);
      const attestation =
        typeof inputProof === "string"
          ? inputProof.startsWith("0x") ? inputProof : "0x" + inputProof
          : toHex(inputProof);

      return { handle, attestation };
    }

    // ===== SUBMIT INTERVAL =====
$("#btnSubmitInterval").onclick = async () => {
  try {
    log("SubmitInterval", "Starting...");
    if (!await connect()) return;

    setStatus("#intervalStatus", "üìù Encrypting interval‚Ä¶", "pending");

    const L = parseInt($("#leftBound").value);
    const R = parseInt($("#rightBound").value);
    log("Interval Values", { L, R });

    // –æ–¥–∏–Ω encrypt —ñ–∑ –¥–≤–æ–º–∞ add16, —è–∫ —É PrivateDonorMatch
    const enc = relayer.createEncryptedInput(
      getAddress(CONFIG.CONTRACT_ADDRESS),
      getAddress(address)
    );
    enc.add16(BigInt(L));
    enc.add16(BigInt(R));

    const { handles, inputProof } = await enc.encrypt();
    log("Interval Encrypt", {
      handleCount: handles.length,
      proofLength: typeof inputProof === "string" ? inputProof.length : inputProof.length
    });

    const raw1 = handles[0]?.handle || handles[0]?.ciphertext || handles[0];
    const raw2 = handles[1]?.handle || handles[1]?.ciphertext || handles[1];
    const h1 = typeof raw1 === "string" ? raw1 : toHex(raw1);
    const h2 = typeof raw2 === "string" ? raw2 : toHex(raw2);
    const att =
      typeof inputProof === "string"
        ? (inputProof.startsWith("0x") ? inputProof : "0x" + inputProof)
        : toHex(inputProof);

    log("Interval Args", {
      h1: h1.slice(0,40) + "...",
      h2: h2.slice(0,40) + "...",
      attLen: att.length
    });

    setStatus("#intervalStatus", "‚õìÔ∏è Submitting to blockchain‚Ä¶", "pending");

    const tx = await contract.submitInterval(h1, h2, att);
    log("Interval Tx", tx.hash);
    const receipt = await tx.wait();
    log("Interval Receipt", { blockNumber: receipt.blockNumber, logCount: receipt.logs.length });

  
let intervalId = "1";
try {
  if (typeof contract.nextIntervalId === "function") {
    const next = await contract.nextIntervalId();
    intervalId = (BigInt(next) - 1n).toString();
  }
} catch {}


    $("#intervalIdDisplay").textContent = intervalId;
    $("#intervalAddressDisplay").textContent = address.slice(0,6) + "‚Ä¶" + address.slice(-4);
    $("#intervalInfo").style.display = "grid";

    setStatus("#intervalStatus", `‚úÖ Interval registered! ID: ${intervalId}`, "success");
    logSuccess("SubmitInterval", `ID=${intervalId}`);

    $("#hitIntervalId").value = intervalId;
    $("#decryptIntervalId").value = intervalId;
  } catch (e) {
    logError("SubmitInterval", e);
    setStatus("#intervalStatus", "‚ùå " + (e.message || e), "error");
  }
};

    // ===== SUBMIT SHOT =====
$("#btnSubmitShot").onclick = async () => {
  try {
    log("SubmitShot", "Starting...");
    if (!await connect()) return;

    setStatus("#shotStatus", "üìù Encrypting shot‚Ä¶", "pending");

    const X = parseInt($("#shotX").value);
    log("Shot X", X);

    const { handle, attestation } = await encrypt16(X);
    log("Shot Args", {
      handle: handle.slice(0,40) + "...",
      attLen: attestation.length
    });

    setStatus("#shotStatus", "‚õìÔ∏è Submitting to blockchain‚Ä¶", "pending");

    const tx = await contract.submitShot(handle, attestation);
    log("Shot Tx", tx.hash);
    const receipt = await tx.wait();
    log("Shot Receipt", { blockNumber: receipt.blockNumber, logCount: receipt.logs.length });

let shotId = "1";
try {
  if (typeof contract.nextShotId === "function") {
    const next = await contract.nextShotId();
    shotId = (BigInt(next) - 1n).toString();
  }
} catch {}

    $("#shotIdDisplay").textContent = shotId;
    $("#shotAddressDisplay").textContent = address.slice(0,6) + "‚Ä¶" + address.slice(-4);
    $("#shotInfo").style.display = "grid";

    setStatus("#shotStatus", `‚úÖ Shot registered! ID: ${shotId}`, "success");
    logSuccess("SubmitShot", `ID=${shotId}`);

    $("#hitShotId").value = shotId;
    $("#decryptShotId").value = shotId;
  } catch (e) {
    logError("SubmitShot", e);
    setStatus("#shotStatus", "‚ùå " + (e.message || e), "error");
  }
};

    // ===== COMPUTE HIT =====
    $("#btnComputeHit").onclick = async () => {
      try {
        log("ComputeHit", "Starting...");
        if (!await connect()) return;

        setStatus("#hitStatus", "üîç Verifying entities‚Ä¶", "pending");

        const intervalId = parseInt($("#hitIntervalId").value);
        const shotId = parseInt($("#hitShotId").value);
        const nearR = BigInt(parseInt($("#nearRadius").value));
        const centerR = BigInt(parseInt($("#centerRadius").value));

        const intervalExists = await contract.intervalExists(intervalId);
        const shotExists = await contract.shotExists(shotId);
        if (!intervalExists) throw new Error(`‚ùå Interval ID ${intervalId} does not exist`);
        if (!shotExists) throw new Error(`‚ùå Shot ID ${shotId} does not exist`);

        logSuccess("Verify", "Interval & Shot exist");
        setStatus("#hitStatus", "üîê Encrypting radii‚Ä¶", "pending");

        // –æ–¥–∏–Ω encrypt —ñ–∑ –¥–≤–æ–º–∞ add16 –¥–ª—è nearR + centerR
        const enc = relayer.createEncryptedInput(
          getAddress(CONFIG.CONTRACT_ADDRESS),
          getAddress(address)
        );
        enc.add16(nearR);
        enc.add16(centerR);

        const { handles, inputProof } = await enc.encrypt();
        log("Hit Encrypt", {
          handleCount: handles.length,
          proofLength: typeof inputProof === "string" ? inputProof.length : inputProof.length
        });

        const rawN = handles[0]?.handle || handles[0]?.ciphertext || handles[0];
        const rawC = handles[1]?.handle || handles[1]?.ciphertext || handles[1];
        const encNear = typeof rawN === "string" ? rawN : toHex(rawN);
        const encCenter = typeof rawC === "string" ? rawC : toHex(rawC);

        const attestation =
          typeof inputProof === "string"
            ? inputProof.startsWith("0x") ? inputProof : "0x" + inputProof
            : toHex(inputProof);

        log("Hit Args", {
          intervalId,
          shotId,
          encNear: encNear.slice(0,40) + "...",
          encCenter: encCenter.slice(0,40) + "...",
          attLen: attestation.length
        });

        setStatus("#hitStatus", "‚õìÔ∏è Computing hit (homomorphic)‚Ä¶", "pending");

        const tx = await contract.computeHit(
          intervalId,
          shotId,
          encNear,
          encCenter,
          attestation
        );
        log("ComputeHit Tx", tx.hash);
        const receipt = await tx.wait();
        log("ComputeHit Receipt", {
          blockNumber: receipt.blockNumber,
          status: receipt.status
        });

        if (receipt.status !== 1) throw new Error("Transaction reverted");

        setStatus("#hitStatus", "üìä Fetching hit handle‚Ä¶", "pending");

        const handle = await contract.hitHandle(intervalId, shotId);
        log("HitHandle", handle);

        $("#hitHandleOutput").textContent = "Hit Handle:\n" + handle;
        $("#hitHandleOutput").style.display = "block";

        setStatus("#hitStatus", "‚úÖ Hit computed successfully", "success");
        logSuccess("ComputeHit", `Handle=${handle.slice(0,20)}...`);

        $("#decryptIntervalId").value = intervalId;
        $("#decryptShotId").value = shotId;
      } catch (e) {
        logError("ComputeHit", e);
        setStatus("#hitStatus", "‚ùå " + (e.message || e), "error");
      }
    };

    // ===== GET HANDLE =====
    $("#btnGetHandle").onclick = async () => {
      try {
        log("GetHandle", "Starting...");
        if (!await connect()) return;

        const intervalId = parseInt($("#decryptIntervalId").value);
        const shotId = parseInt($("#decryptShotId").value);

        setStatus("#decryptStatus", "üìä Retrieving handle‚Ä¶", "pending");

        const handle = await contract.hitHandle(intervalId, shotId);
        log("Handle", handle);

        $("#hitHandleOutput").textContent = "Hit Handle:\n" + handle;
        $("#hitHandleOutput").style.display = "block";

        setStatus("#decryptStatus", "‚úÖ Handle retrieved", "success");
      } catch (e) {
        logError("GetHandle", e);
        setStatus("#decryptStatus", "‚ùå " + (e.message || e), "error");
      }
    };

    // ===== MAKE PUBLIC =====
    $("#btnMakePublic").onclick = async () => {
      try {
        log("MakePublic", "Starting...");
        if (!await connect()) return;

        const intervalId = parseInt($("#decryptIntervalId").value);
        const shotId = parseInt($("#decryptShotId").value);

        setStatus("#decryptStatus", "üîì Making hit public‚Ä¶", "pending");

        const tx = await contract.makeHitPublic(intervalId, shotId);
        log("MakePublic Tx", tx.hash);
        const receipt = await tx.wait();
        log("MakePublic Receipt", {
          blockNumber: receipt.blockNumber,
          status: receipt.status
        });

        if (receipt.status !== 1) throw new Error("Transaction reverted");

        setStatus("#decryptStatus", "‚úÖ Hit is now public", "success");
      } catch (e) {
        logError("MakePublic", e);
        setStatus("#decryptStatus", "‚ùå " + (e.message || e), "error");
      }
    };

    // ===== PUBLIC DECRYPT (Relayer 0.3.x, —è–∫ —É –µ—Ç–∞–ª–æ–Ω—ñ) =====
    async function decryptHit(rawHandle) {
      if (!relayer) throw new Error("Relayer not initialized");

      const handle = cleanHandle(rawHandle);
      if (!handle.startsWith("0x") || handle.length !== 66)
        throw new Error("Invalid handle format (must be bytes32)");

      const request = [handle];
      console.log("üîé publicDecrypt request:", request);

      const out = await relayer.publicDecrypt(request);
      console.log("üîç publicDecrypt output:", out);

      if (!out || typeof out !== "object" || !out.clearValues)
        throw new Error("Invalid decrypt response (no clearValues)");

      const v =
        out.clearValues[handle] ??
        out.clearValues[handle.toLowerCase()];

      if (v === undefined) throw new Error("Decrypt produced no value");

      console.log("üîê clear value:", v);
      return Number(v); // 0,1,2
    }

    // ===== DECRYPT BUTTON =====
    $("#btnDecrypt").onclick = async () => {
      try {
        await connect();

        const raw = $("#hitHandleOutput").textContent.trim();
        const handle = cleanHandle(raw);
        console.log("Decrypting handle:", handle);

        setStatus("#decryptStatus", "üîì Decrypting via relayer‚Ä¶", "pending");
        const zone = await decryptHit(handle);

        const intervalId = $("#decryptIntervalId").value;
        const shotId = $("#decryptShotId").value;

        const resultDiv = $("#hitResult");
        let title, desc, cls="match-result";

        if (zone === 2) {
          title = "üéØ CENTER HIT";
          desc = `Shot #${shotId} is in the center of interval #${intervalId}.`;
        } else if (zone === 1) {
          title = "‚úÖ NEAR HIT";
          desc = `Shot #${shotId} is near the hidden interval #${intervalId}.`;
        } else {
          title = "‚ùå FAR";
          desc = `Shot #${shotId} is far from interval #${intervalId}.`;
          cls = "match-result no-match";
        }

        resultDiv.className = cls;
        resultDiv.innerHTML =
          `<div style="font-size:1.2rem;font-weight:600;margin-bottom:8px;">${title}</div>
           <div style="color:#d1d5db;font-size:14px;">${desc}</div>`;
        resultDiv.style.display = "block";

        setStatus("#decryptStatus", "‚úÖ Hit result decrypted", "success");
      } catch (e) {
        console.error("Decrypt failed:", e);
        setStatus("#decryptStatus", "‚ùå " + (e.message || e), "error");
      }
    };

    log("Script", "‚úÖ All handlers attached and ready");
  </script>
</body>
</html>
