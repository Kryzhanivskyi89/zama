<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Blind Freelance Match ‚Äî FHEVM Demo</title>
  <style>
    body{font-family:Inter,system-ui,Arial,sans-serif;background:#0b1020;color:#e6eef8;margin:0;padding:28px;}
    .wrap{max-width:980px;margin:0 auto;display:flex;flex-direction:column;gap:18px;}
    header{display:flex;justify-content:space-between;align-items:center;}
    h1{margin:0;font-size:20px}
    .card{background:rgba(255,255,255,0.03);padding:16px;border-radius:12px;border:1px solid rgba(255,255,255,0.04)}
    label{display:block;font-size:13px;margin-top:8px;color:#9fb0d2}
    input,select{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#e6eef8;margin-top:6px}
    .row{display:flex;gap:10px;margin-top:12px;flex-wrap:wrap}
    button{padding:10px 14px;border-radius:10px;border:0;background:linear-gradient(90deg,#3b82f6,#8b5cf6);color:white;cursor:pointer}
    button.secondary{background:rgba(255,255,255,0.06)}
    pre{background:#071024;padding:12px;border-radius:8px;overflow:auto;color:#9fb0d2}
    .muted{color:#93a6c1;font-size:13px}
    .small{font-size:13px;color:#93a6c1}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>üîí Blind Freelance Match ‚Äî FHE Demo</h1>
      <div>
        <button id="btnConnect">Connect Wallet</button>
      </div>
    </header>

    <!-- Submit Freelancer -->
    <section class="card">
      <h2 style="margin:0 0 8px 0">1) Submit Freelancer (encrypted)</h2>
      <div class="small muted">Encrypt freelancer's skills (bitmask), level and rate (euint16)</div>

      <label>Skills (select one or many)</label>
      <div id="freelancerSkills">
        <label><input type="checkbox" value="0"> JavaScript</label>
        <label><input type="checkbox" value="1"> Solidity</label>
        <label><input type="checkbox" value="2"> Python</label>
        <label><input type="checkbox" value="3"> Rust</label>
      </div>

      <label>Level (0-255)</label>
      <input id="freelancerLevel" type="number" min="0" max="255" value="5">

      <label>Rate (uint16)</label>
      <input id="freelancerRate" type="number" min="0" max="65535" value="50">

      <div class="row">
        <button id="btnSubmitFreelancer">Submit Freelancer</button>
        <div id="freelancerStatus" class="small muted"></div>
      </div>
      <pre id="freelancerInfo" style="display:none">‚Äî</pre>
    </section>

    <!-- Submit Job -->
    <section class="card">
      <h2 style="margin:0 0 8px 0">2) Submit Job (encrypted)</h2>
      <div class="small muted">Encrypt job's required skills (bitmask), minLevel and maxBudget</div>

      <label>Required Skills</label>
      <div id="jobSkills">
        <label><input type="checkbox" value="0"> JavaScript</label>
        <label><input type="checkbox" value="1"> Solidity</label>
        <label><input type="checkbox" value="2"> Python</label>
        <label><input type="checkbox" value="3"> Rust</label>
      </div>

      <label>Min Level (0-255)</label>
      <input id="jobMinLevel" type="number" min="0" max="255" value="3">

      <label>Max Budget (uint16)</label>
      <input id="jobMaxBudget" type="number" min="0" max="65535" value="100">

      <div class="row">
        <button id="btnSubmitJob" class="secondary">Submit Job</button>
        <div id="jobStatus" class="small muted"></div>
      </div>
      <pre id="jobInfo" style="display:none">‚Äî</pre>
    </section>

    <!-- Compute Match -->
    <section class="card">
      <h2 style="margin:0 0 8px 0">3) Compute Match (homomorphic)</h2>
      <div class="small muted">Call computeMatch(freelancerId, jobId) ‚Äî contract computes encrypted bool</div>

      <label>Freelancer ID</label>
      <input id="computeFreelancerId" type="number" min="1" value="1">

      <label>Job ID</label>
      <input id="computeJobId" type="number" min="1" value="1">

      <div class="row">
        <button id="btnComputeMatch">Compute Match</button>
        <div id="computeStatus" class="small muted"></div>
      </div>

      <pre id="matchHandleOutput" style="display:none">‚Äî</pre>
    </section>

    <!-- Decrypt -->
    <section class="card">
      <h2 style="margin:0 0 8px 0">4) Get Handle / Make Public / Decrypt</h2>
      <div class="small muted">Get handle from contract, optionally make it public, then publicDecrypt via relayer</div>

      <label>Freelancer ID</label>
      <input id="decryptFreelancerId" type="number" min="1" value="1">

      <label>Job ID</label>
      <input id="decryptJobId" type="number" min="1" value="1">

      <div class="row">
        <button id="btnGetHandle" class="secondary">Get Handle</button>
        <button id="btnMakePublic">Make Public</button>
        <button id="btnDecrypt" style="background:linear-gradient(90deg,#10b981,#059669)">Decrypt</button>
      </div>

      <div id="decryptStatus" class="small muted" style="margin-top:8px"></div>
      <pre id="decryptResult" style="display:none"></pre>
    </section>

    <footer class="small muted">Relayer SDK 0.3.x format supported ¬∑ All actions logged in console (–£–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é)</footer>
  </div>

  <script type="module">
    // ------------ IMPORTS ------------
    import { initSDK, createInstance, SepoliaConfig } from "https://cdn.zama.org/relayer-sdk-js/0.3.0-5/relayer-sdk-js.js";
    import { BrowserProvider, Contract, getAddress } from "https://cdn.jsdelivr.net/npm/ethers@6.15.0/+esm";

    // ------------ CONFIG ------------
    const CONTRACT_ADDRESS = "0xec062E4Ac7878E6556DB0b51306d7Cbe8eF70D44";

    // Minimal ABI tailored to contract functions
    const ABI = [
      "function submitFreelancer(bytes32,bytes32,bytes32,bytes) external returns (uint256)",
      "function submitJob(bytes32,bytes32,bytes32,bytes) external returns (uint256)",
      "function computeMatch(uint256,uint256) external returns (bytes32)",
      "function makeMatchPublic(uint256,uint256) external",
      "function matchHandle(uint256,uint256) external view returns (bytes32)",
      "function freelancerExists(uint256) external view returns (bool)",
      "function jobExists(uint256) external view returns (bool)",
      "function freelancerOwner(uint256) external view returns (address)",
      "function jobOwner(uint256) external view returns (address)"
    ];

    // ------------ STATE ------------
    let provider, signer, userAddress, contract, relayer;

    const $ = s => document.querySelector(s);

    // ------------ LOG HELPERS (—É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é) ------------
    function ulog(tag, data) { console.log(`%c[${tag}]`, "color:#60a5fa;font-weight:700;", data); }
    function uerr(tag, data) { console.error(`%c[ERROR ${tag}]`, "color:#f87171;font-weight:700;", data); }
    function usuc(tag, data) { console.log(`%c[OK ${tag}]`, "color:#34d399;font-weight:700;", data); }

    // ------------ UTIL: compute bitmask from checkboxes ------------
    function computeBitmask(containerSelector) {
      const container = document.querySelector(containerSelector);
      const checkboxes = container.querySelectorAll('input[type="checkbox"]');
      let mask = 0n;
      checkboxes.forEach((cb, idx) => {
        if (cb.checked) {
          mask = mask | (1n << BigInt(parseInt(cb.value)));
        }
      });
      return mask; // BigInt
    }

    // ------------ UTIL: hex conversion for Uint8Array -> 0x...
    function toHex(u8) {
      if (typeof u8 === "string") return u8;
      if (u8 instanceof Uint8Array || Array.isArray(u8)) {
        return "0x" + Array.from(u8).map(b => b.toString(16).padStart(2,"0")).join("");
      }
      // fallback
      return String(u8);
    }

    // ------------ CONNECT WALLET & RELAYER ------------
    async function connect() {
      try {
        ulog("CONNECT", "–ü–æ—á–∏–Ω–∞—é –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è...");

        if (!window.ethereum) throw new Error("MetaMask not found");
        provider = new BrowserProvider(window.ethereum);
        ulog("CONNECT", "BrowserProvider —Å—Ç–≤–æ—Ä–µ–Ω–æ");

        const accounts = await provider.send("eth_requestAccounts", []);
        signer = await provider.getSigner();
        userAddress = await signer.getAddress();
        ulog("WALLET", `–ê–¥—Ä–µ—Å–∞: ${userAddress}`);

        contract = new Contract(getAddress(CONTRACT_ADDRESS), ABI, signer);
        ulog("CONTRACT", `–Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ –∫–æ–Ω—Ç—Ä–∞–∫—Ç: ${CONTRACT_ADDRESS}`);

        // Init Relayer SDK once
        if (!relayer) {
          ulog("RELAYER", "–Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è SDK...");
          await initSDK();
          relayer = await createInstance({
            ...SepoliaConfig,
            relayerUrl: "https://relayer.testnet.zama.org",
            gatewayUrl: "https://gateway.testnet.zama.org",
            network: window.ethereum,
            debug: true
          });
          usuc("RELAYER", "Relayer instance —Å—Ç–≤–æ—Ä–µ–Ω–æ");
        }

        $("#btnConnect").textContent = userAddress.slice(0,6) + "‚Ä¶" + userAddress.slice(-4);
        usuc("CONNECT", "–ì–æ—Ç–æ–≤–æ");
        return true;
      } catch (e) {
        uerr("CONNECT", e);
        alert("Connection failed: " + (e.message || e));
        return false;
      }
    }

    $("#btnConnect").onclick = connect;

    // ------------ SUBMIT FREELANCER ------------
    $("#btnSubmitFreelancer").onclick = async () => {
      try {
        ulog("SUBMIT FREELANCER", "–°—Ç–∞—Ä—Ç...");
        if (!await connect()) return;

        $("#freelancerStatus").textContent = "Encrypting and submitting...";
        const skillsMask = computeBitmask("#freelancerSkills"); // BigInt
        const level = BigInt(parseInt($("#freelancerLevel").value || "0"));
        const rate = BigInt(parseInt($("#freelancerRate").value || "0"));

        ulog("FREELANCER VALUES", { skillsMask: skillsMask.toString(), level: level.toString(), rate: rate.toString() });

        // Create encrypted input for contract
        const enc = relayer.createEncryptedInput(getAddress(CONTRACT_ADDRESS), getAddress(userAddress));
        // add values as appropriate sizes
        // skillsMask -> euint256
        if (typeof enc.add256 === "function") {
          enc.add256(skillsMask);
        } else {
          // fallback: many SDKs support addBytes or addBig; try add256 name, otherwise push as addUint (may still work)
          enc.add256 ? enc.add256(skillsMask) : enc.addBig ? enc.addBig(skillsMask) : enc.add256 && enc.add256(skillsMask);
        }
        enc.add8(level);
        enc.add16(rate);

        ulog("ENCRYPT", "Encrypting inputs...");
        const { handles, inputProof } = await enc.encrypt();
        ulog("ENCRYPT RESULT", { handles, inputProof });

        // extract handles as hex strings (bytes32)
        const h1 = toHex(handles[0]?.handle ?? handles[0]?.ciphertext ?? handles[0]);
        const h2 = toHex(handles[1]?.handle ?? handles[1]?.ciphertext ?? handles[1]);
        const h3 = toHex(handles[2]?.handle ?? handles[2]?.ciphertext ?? handles[2]);
        const att = typeof inputProof === "string" ? (inputProof.startsWith("0x") ? inputProof : "0x"+inputProof) : toHex(inputProof);

        ulog("HANDLES EXTRACTED", { h1, h2, h3, attPreview: String(att).slice(0,60)+"..." });

        $("#freelancerStatus").textContent = "Submitting tx...";
        const tx = await contract.submitFreelancer(h1, h2, h3, att);
        ulog("TX SENT (submitFreelancer)", tx.hash);
        const receipt = await tx.wait();
        usuc("TX CONFIRMED", { blockNumber: receipt.blockNumber, status: receipt.status });

        // Try to extract returned id from events or receipt (best effort)
        let freelancerId = null;
        try {
          // if function returns via event, examine logs; fallback to 1
          if (receipt && receipt.logs && receipt.logs.length > 0) {
            // not guaranteed; keep simple
            freelancerId = receipt.logs[0]?.topics?.[2] ? BigInt(receipt.logs[0].topics[2]).toString() : null;
          }
        } catch (e) {
          uerr("ID EXTRACT", e);
        }
        if (!freelancerId) freelancerId = "1";

        $("#freelancerInfo").style.display = "block";
        $("#freelancerInfo").textContent = `Freelancer ID: ${freelancerId}\nAddress: ${userAddress}\nHandles:\n${h1}\n${h2}\n${h3}`;
        $("#freelancerStatus").textContent = "Submitted ‚úì (see console)";
        usuc("SUBMIT FREELANCER", `ID ${freelancerId}`);
      } catch (e) {
        uerr("SUBMIT FREELANCER", e);
        $("#freelancerStatus").textContent = "Error: " + (e.message || e);
      }
    };

    // ------------ SUBMIT JOB ------------
    $("#btnSubmitJob").onclick = async () => {
      try {
        ulog("SUBMIT JOB", "–°—Ç–∞—Ä—Ç...");
        if (!await connect()) return;

        $("#jobStatus").textContent = "Encrypting and submitting...";
        const skillsMask = computeBitmask("#jobSkills"); // BigInt
        const minLevel = BigInt(parseInt($("#jobMinLevel").value || "0"));
        const maxBudget = BigInt(parseInt($("#jobMaxBudget").value || "0"));

        ulog("JOB VALUES", { skillsMask: skillsMask.toString(), minLevel: minLevel.toString(), maxBudget: maxBudget.toString() });

        const enc = relayer.createEncryptedInput(getAddress(CONTRACT_ADDRESS), getAddress(userAddress));
        if (typeof enc.add256 === "function") {
          enc.add256(skillsMask);
        } else {
          enc.add256 ? enc.add256(skillsMask) : enc.addBig ? enc.addBig(skillsMask) : enc.add256 && enc.add256(skillsMask);
        }
        enc.add8(minLevel);
        enc.add16(maxBudget);

        ulog("ENCRYPT", "Encrypting job inputs...");
        const { handles, inputProof } = await enc.encrypt();
        ulog("ENCRYPT RESULT", { handles, inputProof });

        const h1 = toHex(handles[0]?.handle ?? handles[0]?.ciphertext ?? handles[0]);
        const h2 = toHex(handles[1]?.handle ?? handles[1]?.ciphertext ?? handles[1]);
        const h3 = toHex(handles[2]?.handle ?? handles[2]?.ciphertext ?? handles[2]);
        const att = typeof inputProof === "string" ? (inputProof.startsWith("0x") ? inputProof : "0x"+inputProof) : toHex(inputProof);

        ulog("HANDLES EXTRACTED (job)", { h1, h2, h3, attPreview: String(att).slice(0,60)+"..." });

        $("#jobStatus").textContent = "Submitting tx...";
        const tx = await contract.submitJob(h1, h2, h3, att);
        ulog("TX SENT (submitJob)", tx.hash);
        const receipt = await tx.wait();
        usuc("TX CONFIRMED (job)", { blockNumber: receipt.blockNumber, status: receipt.status });

        let jobId = null;
        try {
          if (receipt && receipt.logs && receipt.logs.length > 0) {
            jobId = receipt.logs[0]?.topics?.[2] ? BigInt(receipt.logs[0].topics[2]).toString() : null;
          }
        } catch (e) {
          uerr("JOB ID EXTRACT", e);
        }
        if (!jobId) jobId = "1";

        $("#jobInfo").style.display = "block";
        $("#jobInfo").textContent = `Job ID: ${jobId}\nAddress: ${userAddress}\nHandles:\n${h1}\n${h2}\n${h3}`;
        $("#jobStatus").textContent = "Submitted ‚úì (see console)";
        usuc("SUBMIT JOB", `ID ${jobId}`);
      } catch (e) {
        uerr("SUBMIT JOB", e);
        $("#jobStatus").textContent = "Error: " + (e.message || e);
      }
    };

    // ------------ COMPUTE MATCH ------------
    $("#btnComputeMatch").onclick = async () => {
      try {
        ulog("COMPUTE MATCH", "–°—Ç–∞—Ä—Ç...");
        if (!await connect()) return;

        const freelancerId = parseInt($("#computeFreelancerId").value || "0");
        const jobId = parseInt($("#computeJobId").value || "0");
        $("#computeStatus").textContent = "Calling computeMatch...";
        ulog("COMPUTE ARGS", { freelancerId, jobId });

        const tx = await contract.computeMatch(freelancerId, jobId);
        ulog("TX SENT (computeMatch)", tx.hash);
        const receipt = await tx.wait();
        usuc("TX CONFIRMED (computeMatch)", { blockNumber: receipt.blockNumber, status: receipt.status });

        // Fetch handle from contract.matchHandle
        const handle = await contract.matchHandle(freelancerId, jobId);
        ulog("MATCH HANDLE RETRIEVED", handle);

        $("#matchHandleOutput").style.display = "block";
        $("#matchHandleOutput").textContent = "Match Handle:\n" + handle;
        $("#computeStatus").textContent = "Match computed ‚úì";
      } catch (e) {
        uerr("COMPUTE MATCH", e);
        $("#computeStatus").textContent = "Error: " + (e.message || e);
      }
    };

    // ------------ GET HANDLE ------------
    $("#btnGetHandle").onclick = async () => {
      try {
        ulog("GET HANDLE", "–°—Ç–∞—Ä—Ç...");
        if (!await connect()) return;

        const freelancerId = parseInt($("#decryptFreelancerId").value || "0");
        const jobId = parseInt($("#decryptJobId").value || "0");
        $("#decryptStatus").textContent = "Retrieving handle...";
        const handle = await contract.matchHandle(freelancerId, jobId);
        ulog("HANDLE", handle);

        $("#matchHandleOutput").style.display = "block";
        $("#matchHandleOutput").textContent = "Match Handle:\n" + handle;
        $("#decryptStatus").textContent = "Handle retrieved ‚úì";
      } catch (e) {
        uerr("GET HANDLE", e);
        $("#decryptStatus").textContent = "Error: " + (e.message || e);
      }
    };

    // ------------ MAKE PUBLIC ------------
    $("#btnMakePublic").onclick = async () => {
      try {
        ulog("MAKE PUBLIC", "–°—Ç–∞—Ä—Ç...");
        if (!await connect()) return;

        const freelancerId = parseInt($("#decryptFreelancerId").value || "0");
        const jobId = parseInt($("#decryptJobId").value || "0");
        $("#decryptStatus").textContent = "Calling makeMatchPublic...";
        const tx = await contract.makeMatchPublic(freelancerId, jobId);
        ulog("TX SENT (makeMatchPublic)", tx.hash);
        const receipt = await tx.wait();
        usuc("TX CONFIRMED (makeMatchPublic)", { blockNumber: receipt.blockNumber, status: receipt.status });
        $("#decryptStatus").textContent = "Match made public ‚úì";
      } catch (e) {
        uerr("MAKE PUBLIC", e);
        $("#decryptStatus").textContent = "Error: " + (e.message || e);
      }
    };

    // ------------ DECRYPT (publicDecrypt) ------------
    async function publicDecryptHandle(cleanHandle) {
      if (!relayer) throw new Error("Relayer not initialized");
      // validation
      const h = String(cleanHandle).trim();
      if (!h.startsWith("0x") || h.length !== 66) throw new Error("Handle must be bytes32 hex (0x...)");

      ulog("DECRYPT", `–ó–∞–ø–∏—Ç decrypt –¥–ª—è ${h}`);
      const req = [ h ];
      ulog("DECRYPT REQ", req);

      const out = await relayer.publicDecrypt(req);
      ulog("DECRYPT OUT RAW", out);

      if (!out || typeof out !== "object") throw new Error("Invalid decrypt response");

      if (!out.clearValues) throw new Error("Decrypt response missing clearValues");

      const lower = h.toLowerCase();
      const val = out.clearValues[h] ?? out.clearValues[lower];

      if (val === undefined || val === null) throw new Error("No clear value for handle");

      ulog("DECRYPT CLEAR VALUE", val);
      // val could be string "0" or "1" or BigInt-like
      return BigInt(val) === 1n;
    }

    $("#btnDecrypt").onclick = async () => {
      try {
        ulog("DECRYPT BUTTON", "–°—Ç–∞—Ä—Ç...");
        if (!await connect()) return;

        const raw = $("#matchHandleOutput").textContent || "";
        const handle = raw.split("\n").pop().trim();
        ulog("HANDLE TO DECRYPT", handle);

        $("#decryptStatus").textContent = "Decrypting...";
        const isMatch = await publicDecryptHandle(handle);

        $("#decryptResult").style.display = "block";
        if (isMatch) {
          $("#decryptResult").textContent = "‚úÖ MATCH = true";
          $("#decryptResult").style.background = "rgba(16,185,129,0.06)";
        } else {
          $("#decryptResult").textContent = "‚ùå MATCH = false";
          $("#decryptResult").style.background = "rgba(239,68,68,0.06)";
        }
        $("#decryptStatus").textContent = "Decrypt finished ‚úì";
        usuc("DECRYPT RESULT", isMatch);
      } catch (e) {
        uerr("DECRYPT", e);
        $("#decryptStatus").textContent = "Error: " + (e.message || e);
      }
    };

    // attach simple console-ready message
    ulog("SCRIPT", "UI ready ‚Äî attach handlers. –£—Å—ñ –¥—ñ—ó –ª–æ–≥—É—é—Ç—å—Å—è —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é.");
  </script>
</body>
</html>
