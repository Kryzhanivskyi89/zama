<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Secret Health Metrics ‚Äî FHE Demo</title>
  <style>
    body{font-family:Inter,system-ui,Arial,sans-serif;background:#0b1020;color:#e6eef8;margin:0;padding:28px;}
    .wrap{max-width:980px;margin:0 auto;display:flex;flex-direction:column;gap:18px;}
    header{display:flex;justify-content:space-between;align-items:center;}
    h1{margin:0;font-size:20px}
    .card{background:rgba(255,255,255,0.03);padding:16px;border-radius:12px;border:1px solid rgba(255,255,255,0.04)}
    label{display:block;font-size:13px;margin-top:8px;color:#9fb0d2}
    input,select{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#e6eef8;margin-top:6px}
    .row{display:flex;gap:10px;margin-top:12px;flex-wrap:wrap}
    button{padding:10px 14px;border-radius:10px;border:0;background:linear-gradient(90deg,#3b82f6,#8b5cf6);color:white;cursor:pointer}
    button.secondary{background:rgba(255,255,255,0.06)}
    pre{background:#071024;padding:12px;border-radius:8px;overflow:auto;color:#9fb0d2}
    .muted{color:#93a6c1;font-size:13px}
    .small{font-size:13px;color:#93a6c1}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>üîí Secret Health Metrics ‚Äî FHE Demo</h1>
      <div>
        <button id="btnConnect">Connect Wallet</button>
      </div>
    </header>

    <!-- Submit Citizen -->
    <section class="card">
      <h2 style="margin:0 0 8px 0">1) Submit Citizen (encrypted)</h2>
      <div class="small muted">Encrypt citizen: ageGroup (euint8), bmiCategory (euint8), bpIndex (euint16)</div>

      <label>Age Group</label>
      <select id="citizenAgeGroup">
        <option value="0">Child</option>
        <option value="1" selected>Adult</option>
        <option value="2">Senior</option>
      </select>

      <label>BMI Category</label>
      <select id="citizenBmiCategory">
        <option value="0" selected>Normal</option>
        <option value="1">Overweight</option>
        <option value="2">Obese</option>
      </select>

      <label>Blood Pressure Index (0-1000)</label>
      <input id="citizenBpIndex" type="number" min="0" max="1000" value="120">

      <div class="row">
        <button id="btnSubmitCitizen">Submit Citizen</button>
        <div id="citizenStatus" class="small muted"></div>
      </div>
      <pre id="citizenInfo" style="display:none">‚Äî</pre>
    </section>

    <!-- Submit Region -->
    <section class="card">
      <h2 style="margin:0 0 8px 0">2) Submit Region (encrypted thresholds)</h2>
      <div class="small muted">Encrypt region thresholds: minAgeGroup, maxBmiCategory, maxBpIndex</div>

      <label>Min Age Group</label>
      <select id="regionMinAge">
        <option value="0">Child</option>
        <option value="1" selected>Adult</option>
        <option value="2">Senior</option>
      </select>

      <label>Max BMI Category</label>
      <select id="regionMaxBmi">
        <option value="0">Normal</option>
        <option value="1" selected>Overweight</option>
        <option value="2">Obese</option>
      </select>

      <label>Max Blood Pressure Index</label>
      <input id="regionMaxBp" type="number" min="0" max="1000" value="140">

      <div class="row">
        <button id="btnSubmitRegion" class="secondary">Submit Region</button>
        <div id="regionStatus" class="small muted"></div>
      </div>
      <pre id="regionInfo" style="display:none">‚Äî</pre>
    </section>

    <!-- Compute Match -->
    <section class="card">
      <h2 style="margin:0 0 8px 0">3) Compute Match (homomorphic)</h2>
      <div class="small muted">Call computeHealthMatch(citizenId, regionId) ‚Äî contract computes encrypted boolean</div>

      <label>Citizen ID</label>
      <input id="computeCitizenId" type="number" min="1" value="1">

      <label>Region ID</label>
      <input id="computeRegionId" type="number" min="1" value="1">

      <div class="row">
        <button id="btnComputeMatch">Compute Match</button>
        <div id="computeStatus" class="small muted"></div>
      </div>

      <pre id="matchHandleOutput" style="display:none">‚Äî</pre>
    </section>

    <!-- Decrypt -->
    <section class="card">
      <h2 style="margin:0 0 8px 0">4) Get Handle / Make Public / Decrypt</h2>
      <div class="small muted">Get handle from contract, optionally make it public, then publicDecrypt via relayer</div>

      <label>Citizen ID</label>
      <input id="decryptCitizenId" type="number" min="1" value="1">

      <label>Region ID</label>
      <input id="decryptRegionId" type="number" min="1" value="1">

      <div class="row">
        <button id="btnGetHandle" class="secondary">Get Handle</button>
        <button id="btnMakePublic">Make Public</button>
        <button id="btnDecrypt" style="background:linear-gradient(90deg,#10b981,#059669)">Decrypt</button>
      </div>

      <div id="decryptStatus" class="small muted" style="margin-top:8px"></div>
      <pre id="decryptResult" style="display:none"></pre>
    </section>

    <footer class="small muted">Relayer SDK 0.3.x format supported ¬∑ All actions logged in console (English)</footer>
  </div>

  <script type="module">
    // ------------ IMPORTS ------------
    import { initSDK, createInstance, SepoliaConfig } from "https://cdn.zama.org/relayer-sdk-js/0.3.0-5/relayer-sdk-js.js";
    import { BrowserProvider, Contract, getAddress } from "https://cdn.jsdelivr.net/npm/ethers@6.15.0/+esm";

    // ------------ CONFIG ------------
    // <<< REPLACE THIS WITH DEPLOYED CONTRACT ADDRESS >>>
    const CONTRACT_ADDRESS = "0x3A32DDCDA724d8329E139ad60b98432D9C4A0cf2";

    // Minimal ABI tailored to contract functions
    const ABI = [
      "function submitCitizen(bytes32,bytes32,bytes32,bytes) external returns (uint256)",
      "function submitRegion(bytes32,bytes32,bytes32,bytes) external returns (uint256)",
      "function computeHealthMatch(uint256,uint256) external returns (bytes32)",
      "function makeMatchPublic(uint256,uint256) external",
      "function matchHandle(uint256,uint256) external view returns (bytes32)",
      "function citizenExists(uint256) external view returns (bool)",
      "function regionExists(uint256) external view returns (bool)",
      "function citizenOwner(uint256) external view returns (address)",
      "function regionOwner(uint256) external view returns (address)"
    ];

    // ------------ STATE ------------
    let provider, signer, userAddress, contract, relayer;
    const $ = s => document.querySelector(s);

    // ------------ LOG HELPERS (English) ------------
    function logInfo(tag, data){ console.log(`%c[${tag}]`, "color:#60a5fa;font-weight:700;", data); }
    function logError(tag, data){ console.error(`%c[ERROR ${tag}]`, "color:#f87171;font-weight:700;", data); }
    function logOk(tag, data){ console.log(`%c[OK ${tag}]`, "color:#34d399;font-weight:700;", data); }

    // ------------ UTIL: hex conversion for Uint8Array -> 0x...
    function toHex(u8) {
      if (typeof u8 === "string") return u8;
      if (u8 instanceof Uint8Array || Array.isArray(u8)) {
        return "0x" + Array.from(u8).map(b => b.toString(16).padStart(2,"0")).join("");
      }
      return String(u8);
    }

    // ------------ CONNECT WALLET & RELAYER ------------
    async function connect() {
      try {
        logInfo("CONNECT", "Starting connection...");

        if (!window.ethereum) throw new Error("MetaMask not found");
        provider = new BrowserProvider(window.ethereum);
        logInfo("CONNECT", "BrowserProvider created");

        const accounts = await provider.send("eth_requestAccounts", []);
        signer = await provider.getSigner();
        userAddress = await signer.getAddress();
        logInfo("WALLET", `Address: ${userAddress}`);

        contract = new Contract(getAddress(CONTRACT_ADDRESS), ABI, signer);
        logInfo("CONTRACT", `Contract initialized: ${CONTRACT_ADDRESS}`);

        if (!relayer) {
          logInfo("RELAYER", "Initializing SDK...");
          await initSDK();
          relayer = await createInstance({
            ...SepoliaConfig,
            relayerUrl: "https://relayer.testnet.zama.org",
            gatewayUrl: "https://gateway.testnet.zama.org",
            network: window.ethereum,
            debug: true
          });
          logOk("RELAYER", "Relayer instance created");
        }

        $("#btnConnect").textContent = userAddress.slice(0,6) + "‚Ä¶" + userAddress.slice(-4);
        logOk("CONNECT", "Ready");
        return true;
      } catch (e) {
        logError("CONNECT", e);
        alert("Connection failed: " + (e.message || e));
        return false;
      }
    }

    $("#btnConnect").onclick = connect;

    // ------------ SUBMIT CITIZEN ------------
    $("#btnSubmitCitizen").onclick = async () => {
      try {
        logInfo("SUBMIT CITIZEN", "Start");
        if (!await connect()) return;

        $("#citizenStatus").textContent = "Encrypting and submitting...";
        const ageGroup = BigInt(parseInt($("#citizenAgeGroup").value || "1"));
        const bmiCategory = BigInt(parseInt($("#citizenBmiCategory").value || "0"));
        const bpIndex = BigInt(parseInt($("#citizenBpIndex").value || "0"));

        logInfo("CITIZEN VALUES", { ageGroup: ageGroup.toString(), bmiCategory: bmiCategory.toString(), bpIndex: bpIndex.toString() });

        const enc = relayer.createEncryptedInput(getAddress(CONTRACT_ADDRESS), getAddress(userAddress));
        // add8, add8, add16
        enc.add8(ageGroup);
        enc.add8(bmiCategory);
        enc.add16(bpIndex);

        logInfo("ENCRYPT", "Encrypting inputs...");
        const { handles, inputProof } = await enc.encrypt();
        logInfo("ENCRYPT RESULT", { handles, inputProof });

        const h1 = toHex(handles[0]?.handle ?? handles[0]?.ciphertext ?? handles[0]);
        const h2 = toHex(handles[1]?.handle ?? handles[1]?.ciphertext ?? handles[1]);
        const h3 = toHex(handles[2]?.handle ?? handles[2]?.ciphertext ?? handles[2]);
        const att = typeof inputProof === "string" ? (inputProof.startsWith("0x") ? inputProof : "0x"+inputProof) : toHex(inputProof);

        logInfo("HANDLES EXTRACTED", { h1, h2, h3, attPreview: String(att).slice(0,60)+"..." });

        $("#citizenStatus").textContent = "Submitting tx...";
        const tx = await contract.submitCitizen(h1, h2, h3, att);
        logInfo("TX SENT (submitCitizen)", tx.hash);
        const receipt = await tx.wait();
        logOk("TX CONFIRMED", { blockNumber: receipt.blockNumber, status: receipt.status });

        // best-effort id extraction
        let citizenId = "1";
        try {
          if (receipt && receipt.logs && receipt.logs.length > 0) {
            citizenId = receipt.logs[0]?.topics?.[2] ? BigInt(receipt.logs[0].topics[2]).toString() : citizenId;
          }
        } catch (e) {
          logError("ID_EXTRACT", e);
        }

        $("#citizenInfo").style.display = "block";
        $("#citizenInfo").textContent = `Citizen ID: ${citizenId}\nAddress: ${userAddress}\nHandles:\n${h1}\n${h2}\n${h3}`;
        $("#citizenStatus").textContent = "Submitted ‚úì (see console)";
        logOk("SUBMIT CITIZEN", `ID: ${citizenId}`);
      } catch (e) {
        logError("SUBMIT CITIZEN", e);
        $("#citizenStatus").textContent = "Error: " + (e.message || e);
      }
    };

    // ------------ SUBMIT REGION ------------
    $("#btnSubmitRegion").onclick = async () => {
      try {
        logInfo("SUBMIT REGION", "Start");
        if (!await connect()) return;

        $("#regionStatus").textContent = "Encrypting and submitting...";
        const minAge = BigInt(parseInt($("#regionMinAge").value || "1"));
        const maxBmi = BigInt(parseInt($("#regionMaxBmi").value || "1"));
        const maxBp = BigInt(parseInt($("#regionMaxBp").value || "0"));

        logInfo("REGION VALUES", { minAge: minAge.toString(), maxBmi: maxBmi.toString(), maxBp: maxBp.toString() });

        const enc = relayer.createEncryptedInput(getAddress(CONTRACT_ADDRESS), getAddress(userAddress));
        enc.add8(minAge);
        enc.add8(maxBmi);
        enc.add16(maxBp);

        logInfo("ENCRYPT", "Encrypting region inputs...");
        const { handles, inputProof } = await enc.encrypt();
        logInfo("ENCRYPT RESULT", { handles, inputProof });

        const h1 = toHex(handles[0]?.handle ?? handles[0]?.ciphertext ?? handles[0]);
        const h2 = toHex(handles[1]?.handle ?? handles[1]?.ciphertext ?? handles[1]);
        const h3 = toHex(handles[2]?.handle ?? handles[2]?.ciphertext ?? handles[2]);
        const att = typeof inputProof === "string" ? (inputProof.startsWith("0x") ? inputProof : "0x"+inputProof) : toHex(inputProof);

        logInfo("HANDLES EXTRACTED (region)", { h1, h2, h3, attPreview: String(att).slice(0,60)+"..." });

        $("#regionStatus").textContent = "Submitting tx...";
        const tx = await contract.submitRegion(h1, h2, h3, att);
        logInfo("TX SENT (submitRegion)", tx.hash);
        const receipt = await tx.wait();
        logOk("TX CONFIRMED (region)", { blockNumber: receipt.blockNumber, status: receipt.status });

        let regionId = "1";
        try {
          if (receipt && receipt.logs && receipt.logs.length > 0) {
            regionId = receipt.logs[0]?.topics?.[2] ? BigInt(receipt.logs[0].topics[2]).toString() : regionId;
          }
        } catch (e) {
          logError("REGION_ID_EXTRACT", e);
        }

        $("#regionInfo").style.display = "block";
        $("#regionInfo").textContent = `Region ID: ${regionId}\nAddress: ${userAddress}\nHandles:\n${h1}\n${h2}\n${h3}`;
        $("#regionStatus").textContent = "Submitted ‚úì (see console)";
        logOk("SUBMIT REGION", `ID: ${regionId}`);
      } catch (e) {
        logError("SUBMIT REGION", e);
        $("#regionStatus").textContent = "Error: " + (e.message || e);
      }
    };

    // ------------ COMPUTE MATCH ------------
    $("#btnComputeMatch").onclick = async () => {
      try {
        logInfo("COMPUTE MATCH", "Start");
        if (!await connect()) return;

        const citizenId = parseInt($("#computeCitizenId").value || "0");
        const regionId = parseInt($("#computeRegionId").value || "0");
        $("#computeStatus").textContent = "Calling computeHealthMatch...";
        logInfo("COMPUTE ARGS", { citizenId, regionId });

        const tx = await contract.computeHealthMatch(citizenId, regionId);
        logInfo("TX SENT (computeHealthMatch)", tx.hash);
        const receipt = await tx.wait();
        logOk("TX CONFIRMED (computeHealthMatch)", { blockNumber: receipt.blockNumber, status: receipt.status });

        const handle = await contract.matchHandle(citizenId, regionId);
        logInfo("MATCH HANDLE RETRIEVED", handle);

        $("#matchHandleOutput").style.display = "block";
        $("#matchHandleOutput").textContent = "Match Handle:\n" + handle;
        $("#computeStatus").textContent = "Match computed ‚úì";
      } catch (e) {
        logError("COMPUTE MATCH", e);
        $("#computeStatus").textContent = "Error: " + (e.message || e);
      }
    };

    // ------------ GET HANDLE ------------
    $("#btnGetHandle").onclick = async () => {
      try {
        logInfo("GET HANDLE", "Start");
        if (!await connect()) return;

        const citizenId = parseInt($("#decryptCitizenId").value || "0");
        const regionId = parseInt($("#decryptRegionId").value || "0");
        $("#decryptStatus").textContent = "Retrieving handle...";
        const handle = await contract.matchHandle(citizenId, regionId);
        logInfo("HANDLE", handle);

        $("#matchHandleOutput").style.display = "block";
        $("#matchHandleOutput").textContent = "Match Handle:\n" + handle;
        $("#decryptStatus").textContent = "Handle retrieved ‚úì";
      } catch (e) {
        logError("GET HANDLE", e);
        $("#decryptStatus").textContent = "Error: " + (e.message || e);
      }
    };

    // ------------ MAKE PUBLIC ------------
    $("#btnMakePublic").onclick = async () => {
      try {
        logInfo("MAKE PUBLIC", "Start");
        if (!await connect()) return;

        const citizenId = parseInt($("#decryptCitizenId").value || "0");
        const regionId = parseInt($("#decryptRegionId").value || "0");
        $("#decryptStatus").textContent = "Calling makeMatchPublic...";
        const tx = await contract.makeMatchPublic(citizenId, regionId);
        logInfo("TX SENT (makeMatchPublic)", tx.hash);
        const receipt = await tx.wait();
        logOk("TX CONFIRMED (makeMatchPublic)", { blockNumber: receipt.blockNumber, status: receipt.status });
        $("#decryptStatus").textContent = "Match made public ‚úì";
      } catch (e) {
        logError("MAKE PUBLIC", e);
        $("#decryptStatus").textContent = "Error: " + (e.message || e);
      }
    };

    // ------------ PUBLIC DECRYPT ------------
    async function publicDecryptHandle(cleanHandle) {
      if (!relayer) throw new Error("Relayer not initialized");
      const h = String(cleanHandle).trim();
      if (!h.startsWith("0x") || h.length !== 66) throw new Error("Handle must be bytes32 hex (0x...)");

      logInfo("DECRYPT", `Requesting publicDecrypt for ${h}`);
      const req = [ h ];
      logInfo("DECRYPT REQ", req);

      const out = await relayer.publicDecrypt(req);
      logInfo("DECRYPT OUT RAW", out);

      if (!out || typeof out !== "object") throw new Error("Invalid decrypt response");
      if (!out.clearValues) throw new Error("Decrypt response missing clearValues");

      const lower = h.toLowerCase();
      const val = out.clearValues[h] ?? out.clearValues[lower];

      if (val === undefined || val === null) throw new Error("No clear value for handle");

      logInfo("DECRYPT CLEAR VALUE", val);
      return BigInt(val) === 1n;
    }

    $("#btnDecrypt").onclick = async () => {
      try {
        logInfo("DECRYPT BUTTON", "Start");
        if (!await connect()) return;

        const raw = $("#matchHandleOutput").textContent || "";
        const handle = raw.split("\n").pop().trim();
        logInfo("HANDLE TO DECRYPT", handle);

        $("#decryptStatus").textContent = "Decrypting...";
        const isMatch = await publicDecryptHandle(handle);

        $("#decryptResult").style.display = "block";
        if (isMatch) {
          $("#decryptResult").textContent = "‚úÖ MATCH = true";
          $("#decryptResult").style.background = "rgba(16,185,129,0.06)";
        } else {
          $("#decryptResult").textContent = "‚ùå MATCH = false";
          $("#decryptResult").style.background = "rgba(239,68,68,0.06)";
        }
        $("#decryptStatus").textContent = "Decrypt finished ‚úì";
        logOk("DECRYPT RESULT", isMatch);
      } catch (e) {
        logError("DECRYPT", e);
        $("#decryptStatus").textContent = "Error: " + (e.message || e);
      }
    };

    logInfo("SCRIPT", "UI ready ‚Äî handlers attached. All logs in English.");
  </script>
</body>
</html>
