<!doctype html>
<html lang="uk">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Private Trust Chain â€” FHEVM</title>

<script src="https://cdn.tailwindcss.com"></script>

<style>
  body { background: linear-gradient(135deg, #022c22, #065f46, #0d9488); font-family: 'Inter', sans-serif; color: #e0f2f1; min-height:100vh; padding-bottom:60px; }
  .cyber-box { border: 2px solid rgba(0,255,204,0.4); border-radius:18px; padding:22px; background: rgba(0,0,0,0.2); backdrop-filter: blur(10px); }
  input { padding:12px; border-radius:12px; margin-bottom:8px; background: rgba(255,255,255,0.2); border:1px solid rgba(0,255,200,0.2); color:#e0f2f1; width:100%; }
  #log { height:160px; overflow-y:auto; background: rgba(255,255,255,0.15); padding:12px; border-radius:14px; color:white; font-size:13px; white-space:pre-wrap; }
  .btn { padding:12px 18px; border-radius:14px; font-weight:600; cursor:pointer; transition:0.2s; width:100%; border:none; }
  .btn-connect { background:#0d9488; }
  .btn-primary { background:#14b8a6; }
  .btn-yellow { background:#fbbf24; color:#78350f; }
</style>
</head>

<body class="p-6">

<header class="flex justify-between items-center mb-6">
  <h1 class="text-3xl font-extrabold tracking-wide">ðŸ”— Private Trust Chain</h1>
  <button id="connectBtn" class="btn btn-connect w-40">Connect</button>
</header>

<div class="grid md:grid-cols-2 gap-6">
  <div class="cyber-box">
    <h2 class="text-xl font-semibold mb-3">Add Trust Link</h2>
    <input id="chainName" placeholder="Chain Name (string)"/>
    <input id="chainNote" placeholder="Note (optional)"/>
    <input id="chainId" placeholder="Chain ID (string)"/>
    <input id="trustScore" type="number" min="0" max="65535" placeholder="Encrypted trust value"/>
    <button id="add" class="btn btn-primary mt-2">Encrypt & Add Trust</button>
    <p id="status1" class="mt-2 text-sm"></p>
  </div>

  <div class="cyber-box">
    <h2 class="text-xl font-semibold mb-3">Reveal Chain Trust</h2>
    <input id="chainReveal" placeholder="Chain ID (string)"/>
    <button id="makePublic" class="btn btn-yellow mt-2">Make Public</button>
    <button id="getHandle" class="btn btn-primary mt-2">Get Handle</button>
    <button id="decrypt" class="btn btn-connect mt-2">Public Decrypt</button>

    <p class="mt-3 font-semibold">Encrypted Handle:</p>
    <p id="hbox" class="text-sm break-all"></p>

    <p class="mt-3 font-semibold">Trust Score:</p>
    <p id="result" class="text-2xl font-bold"></p>

    <p id="status2" class="mt-2 text-sm"></p>
  </div>
</div>

<div class="cyber-box mt-6">
  <h2 class="text-lg font-semibold mb-2">ðŸ“œ Logs</h2>
  <div id="log"></div>
</div>

<script type="module">
// imports (Ð·Ð±ÐµÑ€ÐµÐ³Ð»Ð¸ ÑÐº Ñƒ Ñ‚ÐµÐ±Ðµ Ð¿Ñ€Ð°Ñ†ÑŽÐ²Ð°Ð»Ð¾)
import { initSDK, createInstance, SepoliaConfig } from "https://cdn.zama.org/relayer-sdk-js/0.3.0-5/relayer-sdk-js.js";
import { BrowserProvider, Contract, getAddress, keccak256, toUtf8Bytes } from "https://cdn.jsdelivr.net/npm/ethers@6.15.0/+esm";

// ÐºÐ¾Ð½Ñ„Ñ–Ð³Ð¸
const RELAYER_URL = "https://relayer.testnet.zama.org";
const GATEWAY_URL  = "https://gateway.testnet.zama.org";
const CONTRACT = "0xa0198955D420Fa71100C23A2341D6D6446f90379";

const ABI = [
  { "inputs":[{"type":"bytes32","name":"chainId"}],"name":"initChain","outputs":[],"stateMutability":"nonpayable","type":"function" },
  { "inputs":[{"type":"bytes32","name":"chainId"},{"type":"bytes32","name":"extTrust"},{"type":"bytes","name":"att"}],"name":"addTrust","outputs":[],"stateMutability":"nonpayable","type":"function" },
  { "inputs":[{"type":"bytes32","name":"chainId"}],"name":"makePublic","outputs":[],"stateMutability":"nonpayable","type":"function" },
  { "inputs":[{"type":"bytes32","name":"chainId"}],"name":"trustHandle","outputs":[{"type":"bytes32"}],"stateMutability":"view","type":"function" }
];

const $ = s => document.querySelector(s);
const appendLog = (t) => { $("#log").innerText += t + "\n"; console.log(t); };

// helper: convert proof (Array-like or Uint8Array or hex string) to hex
function toHex(input) {
  if (!input) return "";
  // if already hex string with 0x
  if (typeof input === "string") {
    return input.startsWith("0x") ? input.slice(2) : input;
  }
  // if Uint8Array or array
  if (input instanceof Uint8Array || Array.isArray(input)) {
    return Array.from(input).map(b => b.toString(16).padStart(2, "0")).join("");
  }
  // Buffer-like (Node) -> fallback
  try {
    return Array.from(input).map(b => (b & 0xFF).toString(16).padStart(2,"0")).join("");
  } catch (e) {
    return "";
  }
}

// debug helper to inspect relayer instance
function inspectRelayer(r) {
  if (!r) return "relayer=null";
  const keys = Object.keys(r).join(", ");
  return `Relayer keys: ${keys}`;
}

let provider, signer, relayer, contract, addr;

// CONNECT WALLET + INIT relayer
$("#connectBtn").onclick = async () => {
  try {
    appendLog("â–¶ Connecting wallet...");
    provider = new BrowserProvider(window.ethereum);
    await provider.send("eth_requestAccounts", []);
    signer = await provider.getSigner();
    addr = await signer.getAddress();
    appendLog("âœ” Wallet connected: " + addr);

    contract = new Contract(getAddress(CONTRACT), ABI, signer);
    appendLog("âœ” Contract instance ready: " + CONTRACT);

    appendLog("â–¶ initSDK()");
    await initSDK();
    appendLog("âœ” initSDK done");

    appendLog("â–¶ createInstance()");
    relayer = await createInstance({
      ...SepoliaConfig,
      relayerUrl: RELAYER_URL,
      gatewayUrl: GATEWAY_URL,
      network: window.ethereum,
      debug: true
    });
    appendLog("âœ” Relayer instance created");
    appendLog("Relayer inspect: " + inspectRelayer(relayer));

    // quick checks
    appendLog("Relayer has createEncryptedInput?: " + (typeof (relayer && relayer.createEncryptedInput) === "function"));
    appendLog("Relayer has publicDecrypt?: " + (typeof (relayer && relayer.publicDecrypt) === "function"));
    // if relayer has config property - log it (may be undefined in some builds)
    try { appendLog("Relayer.config: " + JSON.stringify(relayer.config || "undefined")); } catch(e) { appendLog("Relayer.config: <unserializable>"); }

  } catch (e) {
    appendLog("ERROR connecting/initializing: " + (e && e.message ? e.message : e));
    console.error(e);
  }
};

// helper: try provider.call to get revert data (simulate)
async function simulateCall(populatedData) {
  try {
    const from = await signer.getAddress();
    const callRes = await contract.provider.call({ to: CONTRACT, data: populatedData, from });
    appendLog("simulate call succeeded: " + callRes);
    return { ok: true, result: callRes };
  } catch (err) {
    appendLog("simulate reverted (raw error): " + (err && err.message ? err.message : err));
    if (err && err.data) {
      appendLog("revert data hex: " + err.data);
    } else if (err && err.error && err.error.data) {
      appendLog("revert data (err.error.data): " + err.error.data);
    }
    return { ok: false, error: err };
  }
}

// ADD TRUST
$("#add").onclick = async () => {
  try {
    $("#status1").textContent = "Encryptingâ€¦";
    const chainIdStr = $("#chainId").value.trim();
    if (!chainIdStr) { $("#status1").textContent = "Enter chainId"; return; }
    const chainId = keccak256(toUtf8Bytes(chainIdStr));
    const score = parseInt($("#trustScore").value || "0");

    appendLog(`â–¶ ADD TRUST: chainId='${chainIdStr}' hash=${chainId} score=${score}`);
    appendLog("Encrypt target contract = " + getAddress(CONTRACT));

    if (!relayer || typeof relayer.createEncryptedInput !== "function") {
      appendLog("ERROR: relayer not initialized or createEncryptedInput missing");
      $("#status1").textContent = "Relayer not ready";
      return;
    }

    // create encrypted input
    appendLog("â–¶ createEncryptedInput()");
    const enc = relayer.createEncryptedInput(getAddress(CONTRACT), addr);
    if (!enc) { appendLog("ERROR: createEncryptedInput returned falsy"); return; }

    // add value (try add16; fallback add)
    if (typeof enc.add16 === "function") enc.add16(BigInt(score));
    else if (typeof enc.add === "function") enc.add(BigInt(score));
    else throw new Error("no add method on encrypted input");

    appendLog("â–¶ encrypt()");
    const { handles, inputProof } = await enc.encrypt();
    appendLog("âœ” handles:", JSON.stringify(handles));
    appendLog("âœ” proof length: " + (inputProof ? (inputProof.length || inputProof.byteLength || "unknown") : "null"));

    const proofHex = toHex(inputProof);
    appendLog("PROOF HEX (first 200 chars): " + proofHex.slice(0, 200));
    appendLog("FULL PROOF LENGTH (bytes): " + (proofHex.length/2));

    // ensure chain exists: call initChain once (idempotent on your contract if you change it later)
    try {
      appendLog("â–¶ calling initChain (idempotent attempt)");
      const tx0 = await contract.initChain(chainId);
      await tx0.wait();
      appendLog("âœ” initChain tx executed");
    } catch (e) {
      appendLog("initChain tx reverted or already exists (ok): " + (e && e.message ? e.message : e));
    }

    // prepare populated tx data for simulation
    appendLog("â–¶ preparing populated transaction for simulation");
    const populated = await contract.populateTransaction.addTrust(chainId, handles[0], inputProof);
    // simulate via provider.call to capture revert data (no gas estimate)
    const sim = await simulateCall(populated.data);
    if (!sim.ok) {
      appendLog("âš ï¸ Simulation failed â€” aborting actual tx send. See logs above.");
      $("#status1").textContent = "Simulation failed (see logs)";
      return;
    }

    // send tx
    appendLog("â–¶ Sending addTrust tx");
    const tx = await contract.addTrust(chainId, handles[0], inputProof);
    appendLog("â³ tx sent: " + tx.hash);
    await tx.wait();
    appendLog("âœ” addTrust succeeded");
    $("#status1").textContent = "Trust added âœ”";

  } catch (e) {
    // show detailed error info
    appendLog("âŒ ERROR addTrust: " + (e && e.message ? e.message : e));
    // ethers v6 error may have error.data or error.error.data
    if (e && e.data) appendLog("error.data: " + JSON.stringify(e.data));
    if (e && e.error && e.error.data) appendLog("error.error.data: " + JSON.stringify(e.error.data));
    if (e && e.transaction) appendLog("error.transaction: " + JSON.stringify(e.transaction));
    console.error(e);
    $("#status1").textContent = "Error â€” see logs";
  }
};

// MAKE PUBLIC
$("#makePublic").onclick = async () => {
  try {
    const id = keccak256(toUtf8Bytes($("#chainReveal").value.trim()));
    const tx = await contract.makePublic(id);
    await tx.wait();
    appendLog("Made public");
    $("#status2").textContent = "Made public âœ”";
  } catch (e) { appendLog("makePublic error: " + (e.message || e)); }
};

// GET HANDLE
$("#getHandle").onclick = async () => {
  try {
    const id = keccak256(toUtf8Bytes($("#chainReveal").value.trim()));
    const h = await contract.trustHandle(id);
    $("#hbox").textContent = h;
    appendLog("Handle: " + h);
    $("#status2").textContent = "Handle loaded âœ”";
  } catch (e) { appendLog("getHandle error: " + (e.message || e)); }
};

// DECRYPT (public)
$("#decrypt").onclick = async () => {
  try {
    const h = $("#hbox").textContent.trim();
    if (!h) { appendLog("No handle"); return; }
    if (!relayer || typeof relayer.publicDecrypt !== "function") { appendLog("Relayer.publicDecrypt not available"); return; }
    const out = await relayer.publicDecrypt([h]);
    appendLog("publicDecrypt out: " + JSON.stringify(out));
    $("#result").textContent = out[h];
    $("#status2").textContent = "Decrypted âœ”";
  } catch (e) { appendLog("decrypt error: " + (e.message || e)); }
};

</script>

</body>
</html>
