<!-- <!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Private Donor Matching ‚Äî Zama FHEVM</title>
  <style>
    :root{
      --bg: linear-gradient(180deg,#071024,#001021);
      --card: rgba(255,255,255,0.04);
      --border: rgba(255,255,255,0.08);
      --text:#e6eef8; --muted:#9fb0c8; --accent:#60a5fa;
      --radius:14px;
    }
    body{margin:0;min-height:100vh;background:var(--bg);color:var(--text);font-family:Inter,system-ui; padding:30px;}
    .wrap{max-width:980px;margin:auto;display:flex;flex-direction:column;gap:20px;}
    header{display:flex;justify-content:space-between;align-items:center}
    h1{margin:0;color:var(--accent)}
    .card{background:var(--card);border:1px solid var(--border);padding:18px;border-radius:var(--radius)}
    label{display:block;margin-top:8px;color:var(--muted);font-size:13px}
    input,select{width:100%;padding:10px;border-radius:10px;border:1px solid var(--border);background:transparent;color:var(--text)}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    .btn{background:linear-gradient(90deg,#60a5fa,#7c3aed);color:#fff;border:none;padding:10px 14px;border-radius:12px;cursor:pointer}
    pre{background:rgba(0,0,0,0.25);padding:10px;border-radius:8px;overflow:auto;color:var(--muted)}
    footer{color:#7b93ab;font-size:13px;text-align:center;margin-top:20px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>üîê Private Donor Matching (Zama FHE)</h1>
      <button id="btnConnect" class="btn">Connect</button>
    </header>

    <section class="card" id="register">
      <h3>1) Register donor profile (encrypt locally)</h3>
      <label>Blood type (code) ‚Äî 0..10</label>
      <input id="inpBlood" type="number" min="0" max="10" value="1"/>
      <label>Age</label>
      <input id="inpAge" type="number" min="0" max="120" value="35"/>
      <label>Marker (0..100)</label>
      <input id="inpMarker" type="number" min="0" max="100" value="40"/>
      <div class="row">
        <button id="btnRegister" class="btn">Encrypt & Register</button>
        <div id="regStatus" style="align-self:center;color:var(--muted)"></div>
      </div>
      <pre id="regLog">‚Äî</pre>
    </section>

    <section class="card" id="match">
      <h3>2) Compute Match (compare candidate)</h3>
      <label>Profile ID to compare to</label>
      <input id="inpProfileId" type="number" min="1" value="1" />
      <label>Candidate Blood Type</label>
      <input id="candBlood" type="number" min="0" max="10" value="1"/>
      <label>Candidate Age</label>
      <input id="candAge" type="number" min="0" max="120" value="34"/>
      <label>Candidate Marker</label>
      <input id="candMarker" type="number" min="0" max="100" value="38"/>
      <div class="row">
        <button id="btnMatch" class="btn">Encrypt Candidate & Compute Match</button>
        <div id="matchStatus" style="align-self:center;color:var(--muted)"></div>
      </div>
      <pre id="matchLog">‚Äî</pre>
    </section>

    <section class="card">
      <h3>3) Make Match Public / Decrypt</h3>
      <div class="row">
        <button id="btnMakePublic" class="btn">Make Match Public (owner only)</button>
        <button id="btnPublicDecrypt" class="btn">Relayer Public Decrypt</button>
      </div>
      <pre id="decryptLog">‚Äî</pre>
    </section>

    <footer>Built with ‚ù§Ô∏è + Zama FHEVM Relayer SDK ¬∑ All console actions logged</footer>
  </div>

  <script type="module">
    // Use official Relayer SDK CDN (example version); adapt to latest if needed
    import { initSDK, createInstance, SepoliaConfig } from "https://cdn.zama.org/relayer-sdk-js/0.3.0-5/relayer-sdk-js.js";
    import { BrowserProvider, Contract, getAddress } from "https://cdn.jsdelivr.net/npm/ethers@6.15.0/+esm";

    const CONFIG = {
      RELAYER_URL: "https://relayer.testnet.zama.org",
      GATEWAY_URL: "https://gateway.testnet.zama.org",
      CONTRACT_ADDRESS: "0xYourContractAddressHere" // <- replace with deployed contract
    };

    const ABI = [
      "function registerProfile(bytes32,bytes32,bytes32,bytes) external returns (uint256)",
      "function computeMatch(uint256,bytes32,bytes32,bytes32,bytes) external returns (bytes32)",
      "function lastMatchHandle(uint256) external view returns (bytes32)",
      "function makeMatchPublic(uint256) external",
      "function ownerOf(uint256) external view returns (address)"
    ];

    let provider, signer, address, contract, relayer;

    const $ = s => document.querySelector(s);
    function toHex(u8){
      return '0x' + Array.from(u8).map(b=>b.toString(16).padStart(2,'0')).join('');
    }

    async function connect() {
      if (signer) return;
      provider = new BrowserProvider(window.ethereum);
      await provider.send("eth_requestAccounts", []);
      signer = await provider.getSigner();
      address = await signer.getAddress();
      contract = new Contract(getAddress(CONFIG.CONTRACT_ADDRESS), ABI, signer);
      $("#btnConnect").textContent = address.slice(0,6) + '‚Ä¶' + address.slice(-4);
      console.log("[connect] connected:", address);

      if (!relayer) {
        console.log("[connect] init SDK");
        await initSDK();
        relayer = await createInstance({
          ...SepoliaConfig,
          relayerUrl: CONFIG.RELAYER_URL,
          gatewayUrl: CONFIG.GATEWAY_URL,
          network: window.ethereum,
          debug: true
        });
        console.log("[connect] relayer instance ready");
      }
    }

    $("#btnConnect").onclick = connect;

    // Register profile (encrypt inputs via relayer)
    $("#btnRegister").onclick = async () => {
      try {
        await connect();
        const blood = BigInt(parseInt($("#inpBlood").value));
        const age = BigInt(parseInt($("#inpAge").value));
        const marker = BigInt(parseInt($("#inpMarker").value));
        $("#regStatus").textContent = "Encrypting...";
        console.log("[register] values:", {blood: String(blood), age: String(age), marker: String(marker)});

        const enc = relayer.createEncryptedInput(getAddress(CONFIG.CONTRACT_ADDRESS), getAddress(address));
        enc.add8(blood);
        enc.add8(age);
        enc.add16(marker);
        const { handles, inputProof } = await enc.encrypt();

        // robust extraction of handles & proof formatting (avoid revert due to wrong attestation format)
        const h1 = handles[0]?.handle || handles[0]?.ciphertext || handles[0];
        const h2 = handles[1]?.handle || handles[1]?.ciphertext || handles[1];
        const h3 = handles[2]?.handle || handles[2]?.ciphertext || handles[2];
        const att = typeof inputProof === "string" ? (inputProof.startsWith("0x") ? inputProof : "0x" + inputProof) : toHex(inputProof);

        console.log("[register] prepared args:", {h1,h2,h3,att});
        $("#regLog").textContent = "Prepared handles:\n" + JSON.stringify({h1,h2,h3}) + "\nattestation:\n" + att;

        const tx = await contract.registerProfile(h1,h2,h3,att);
        console.log("[register] tx sent", tx);
        $("#regStatus").textContent = "Tx sent...";
        await tx.wait();
        $("#regStatus").textContent = "Registered ‚úÖ";
        console.log("[register] tx mined");
      } catch (e) {
        console.error("[register] error", e);
        $("#regStatus").textContent = "Error: " + (e.message || e);
      }
    };

    // Compute match: encrypt candidate and call computeMatch
    $("#btnMatch").onclick = async () => {
      try {
        await connect();
        const profileId = parseInt($("#inpProfileId").value);
        const blood = BigInt(parseInt($("#candBlood").value));
        const age = BigInt(parseInt($("#candAge").value));
        const marker = BigInt(parseInt($("#candMarker").value));
        $("#matchStatus").textContent = "Encrypting candidate...";
        console.log("[match] profileId",profileId, {blood,age,marker});

        const enc = relayer.createEncryptedInput(getAddress(CONFIG.CONTRACT_ADDRESS), getAddress(address));
        enc.add8(blood);
        enc.add8(age);
        enc.add16(marker);
        const { handles, inputProof } = await enc.encrypt();

        const h1 = handles[0]?.handle || handles[0]?.ciphertext || handles[0];
        const h2 = handles[1]?.handle || handles[1]?.ciphertext || handles[1];
        const h3 = handles[2]?.handle || handles[2]?.ciphertext || handles[2];
        const att = typeof inputProof === "string" ? (inputProof.startsWith("0x") ? inputProof : "0x" + inputProof) : toHex(inputProof);

        console.log("[match] args:", {profileId,h1,h2,h3,att});
        $("#matchLog").textContent = "Prepared: " + JSON.stringify({h1,h2,h3});

        // call computeMatch(profileId, handles..., att)
        const tx = await contract.computeMatch(profileId, h1, h2, h3, att);
        $("#matchStatus").textContent = "Tx sent...";
        console.log("[match] tx", tx);
        await tx.wait();
        $("#matchStatus").textContent = "Match computed (onchain).";
        const handle = await contract.lastMatchHandle(profileId);
        $("#matchLog").textContent += "\nResult handle: " + handle;
        console.log("[match] result handle", handle);
      } catch (e) {
        console.error("[match] error", e);
        $("#matchStatus").textContent = "Error: " + (e.message || e);
      }
    };

    // Make match public
    $("#btnMakePublic").onclick = async () => {
      try {
        await connect();
        const profileId = parseInt($("#inpProfileId").value);
        $("#decryptLog").textContent = "Sending makeMatchPublic transaction...";
        const tx = await contract.makeMatchPublic(profileId);
        console.log("[makePublic] tx", tx);
        await tx.wait();
        $("#decryptLog").textContent = "Match made publicly decryptable ‚úÖ";
      } catch (e) {
        console.error("[makePublic] error", e);
        $("#decryptLog").textContent = "Error: " + (e.message || e);
      }
    };

    // Public decrypt via relayer
    $("#btnPublicDecrypt").onclick = async () => {
      try {
        await connect();
        const profileId = parseInt($("#inpProfileId").value);
        const handle = await contract.lastMatchHandle(profileId);
        if (!handle || handle === '0x0000000000000000000000000000000000000000000000000000000000000000') {
          throw new Error("No match handle on-chain");
        }
        $("#decryptLog").textContent = "Requesting public decrypt via relayer...";
        console.log("[decrypt] handle", handle);
        // relayer.publicDecrypt expects array of handles (strings)
        const result = await relayer.publicDecrypt([handle]);
        console.log("[decrypt] relayer result:", result);
        $("#decryptLog").textContent = "Relayer decrypt returned (raw):\n" + JSON.stringify(result, null, 2);

        // extract first clear value
        const keys = Object.keys(result.clearValues || {});
        const key = keys[0];
        const raw = Number(result.clearValues[key]);
        $("#decryptLog").textContent += "\nDecrypted numeric score: " + raw;
      } catch (e) {
        console.error("[decrypt] error", e);
        $("#decryptLog").textContent = "Error: " + (e.message || e);
      }
    };

  </script>
</body>
</html> -->
